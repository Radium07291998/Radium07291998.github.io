<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Technical Solution for Everyday Science Visualization - Radium's Website
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="Radium's Website" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="resume.html">Resume</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Radium's Website</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="resume.html">Resume</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Portfolios.html">Portfolios</a></li>
        
            <li><a href="Literature_Review_Notes.html">Literature Review Notes</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		var currentURL = 'Technical_Solution_for_Everyday_Science_Visualization.html';
		currentURL = currentURL.substr(0,currentURL.length-5);
		$('#menu_item_'+currentURL).addClass('is_active');
	});
</script>
<div class="row">

    <div id="single-page-wrap">
        <h1>Technical Solution for Everyday Science Visualization</h1>

        <div class="markdown-body post-page">
        <h3><a id="a-360-panorama-player" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>A. 360 Panorama Player</h3>
<p>The goal of this project was to develop a panorama player that could display 360-degree panoramic images, providing an immersive viewing experience. The chosen method for displaying the panorama was through a spherical projection.</p>
<p>The implementation process involved several steps:</p>
<ol>
<li>
<p>Creating a Sphere: A sphere was created by dividing its surface into numerous small triangles. By sufficiently refining the division, the sphere would appear smooth. The sphere was constructed using a combination of longitudinal and latitudinal lines, forming rectangles that could be treated as two triangles. The vertices were generated using a nested loop iterating over the latitudinal and longitudinal angles.</p>
</li>
<li>
<p>Determining Vertex and Texture Coordinates: The coordinates for the vertices on the sphere's surface were determined using mathematical formulas, taking into account the radius and the angles.</p>
</li>
<li>
<p>Texture Mapping: Texture coordinates (u, v) were used to map the texture onto the sphere's surface. This process, known as UV mapping, involved mapping the vertex coordinates to the corresponding texture coordinates to achieve the desired texture loading.</p>
</li>
<li>
<p>MVP Matrix and Coordinate Transformations: To achieve the immersive 360-degree effect, various matrix transformations were applied to the display coordinates. The Model-View-Projection (MVP) matrix, composed of the ModelMatrix, ViewMatrix, and ProjectionMatrix, was used to project the scene onto the screen. Additionally, clipping was considered to limit the visible area to ensure proper display, although it was not implemented in this project.</p>
</li>
<li>
<p>User Interaction: The sphere could be rotated based on user input, providing an interactive viewing experience. In this implementation, the sphere rotation was controlled by mouse movements. However, the same concept could be applied to sensor-based rotation by obtaining rotation data. The ViewMatrix was updated based on user touch events to update the scene's position and achieve the desired rotation effect.</p>
</li>
</ol>
<h3><a id="b-implementation-of-3d-model-annotation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>B. Implementation of 3D Model Annotation</h3>
<p>The objective of this project was to enable annotation of specific points on a 3D model by mouse clicks, allowing the addition of one or more annotations in the scene. The annotations could be dragged and transformed, maintaining their position relative to the model's animations, translations, and rotations.</p>
<p>The implementation process involved the following steps:</p>
<ol>
<li>
<p>Raycaster for Annotation Coordinate Selection: The mouse click position, initially in screen coordinates, needed to be transformed into 3D space coordinates. A ray was cast from the camera position through the mouse position, and the intersection point with the model's surface was used as the annotation point in 3D space.</p>
</li>
<li>
<p>Interactive Interaction with WebGL: To add annotations to the scene, a separate shader was created for rendering the annotations independently of the scene. Each annotation was represented by a hotspot, consisting of a mesh and a material. Data information required for rendering, such as position, UV coordinates, color, and index, was passed to the shader. Each hotspot was associated with a hotspot object, binding it to its specific mesh and material.</p>
</li>
<li>
<p>Reusing Mesh and Material: Considering the simplicity of hotspot information, multiple hotspots could share the same mesh and material. By consolidating the meshes and materials of multiple hotspots, the rendering process was optimized, reducing it from multiple iterations to a single operation and improving performance.</p>
</li>
<li>
<p>Vertex Stream Compression: To save space and optimize data transmission to the shader, compression techniques were employed to reduce the redundancy in hotspot data.</p>
</li>
<li>
<p>Hotspot Occlusion: Proper occlusion handling between hotspots and between hotspots and other objects in the scene was considered to ensure correct rendering.</p>
</li>
<li>
<p>Mouse Drag Transformation of Hotspot Positions: When dragging a hotspot, the mouse position needed to be continuously tracked and converted into 3D space coordinates</p>
</li>
</ol>

        </div>
    </div>
</div>              
 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
